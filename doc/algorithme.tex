\documentclass[11pt]{report}

\usepackage{fullpage}
\usepackage{titlesec}
\usepackage{biblatex}
\addbibresource{biblio.bib}
\usepackage[utf8]{inputenc}  
\usepackage[T1]{fontenc}  
\usepackage[francais]{babel}
\usepackage{minted}
\begin{document}
\title{Algorithme Duty Planner}

\author{Quentin Mallet}


\maketitle

\tableofcontents

\section{Introduction}
Ce pdf documente l'algorithme utilisé par le programme duty planner.
Ce programme initialement écrit en OO basic\cite{basicguide} comme macro pour openoffice base a ensuite été réécrit et modifié du point de vue de son architecture pour fonctionner sous la forme d'un jar exécutable ne requérant que l'installation préalable du "java runtime environment". 
Comme lors de la réalisation de ce projet l'auteur n'avais pas encore compris l'importance de documenter correctement toutes les étapes de la réalisation la seule ressource chronologique utilisée pour la réalisation de ce document est le résultat de "git log" sur les dépôts de code de l'auteur.

\chapter{Cahier Des Charges}
\section{Préambule}
La réalisation d'un cahier des charges complet et cohérent a été un premier challenge, en effet lors de cette étape essentielle du projet l'auteur n'avait pas encore conscience de l'existence de SEA\cite{sea} aussi ce processus a demandé un grand nombre de tatonnements et des communications répétées avec les utilisateurs. 
A posteriori un shéma entité association a été élaboré pour vérifier la validité du design de la base de donné.

Plusieurs versions de l'algorithme ont existé, les sections suivantes décrivent le processus de création du cahier des charges et ses modifications entre chaque version. 
Il est important de noter que les numéros de version donnés par la suite ne correspondent à aucun tag dans les dépôts git et ne servent que comme points de repère au sein de ce document.

\section{Première version}
Lors du design de la première version de l'algorithme duty planner le processus s'est déroulé comme suit : 
\begin{itemize}
\item découverte de la problématique
\item explication du processus de travail utilisé jusqu'alors
\item discussions sur les différents problèmes que ce processus de travail entraînait tant au niveau humain que logistique
\item définition formelle (autant que faire se peut) du cahier des charges
\end{itemize}

\subsection{Problématique}
L'algorithme discuté dans ce document est celui qui est implémenté dans le programme duty planner. 
La problématique posée peut être décrite de la manière la plus générale comme suit : 

La réalisation d'un tableau de gardes (un calendrier assignant chaque date à un membre d'un groupe de la manière la plus juste possible) est un processus long(entre trois et six heures pour un seul service, plusieurs mois pour la répartitions des gardes aux urgences et à l'intérieur au sein de tout l'hôpital) et fastidieux. Ce travail n'est pas extrêmement intéressant et entraîne des risques d'un point de vue social (insatisfaction des gens assignés à certains jours,nouvel an par exemple, manque de confiance quant à l'impartialité de la personne le réalisant, etc). 
De plus il demande une grande synchronisation entre les participants, étant habituellement généré par une ou deux personnes celles ci peuvent voir leur travail réduit à néant si, au bout du tableau elles reçoivent une communication d'une des personnes devant se voir assigner une garde qui les notifie de son absence sur une certaine période. Le rééquilibrage du tableau demande donc de tout recommencer, ce qui peux n-upler le temps passé à travailler dessus.

\subsection{Utilisateurs}
Lors de la rédaction de la macro openoffice ayant servi de base au programme final les utilisateurs cible étaient les internes et médecins rédigeant des tableaux de garde pour leur seul service et sur des durées de six mois.

\subsection{Cahier des Charges}
En l'absence de l'aide méthodologique donnée par l'utilisation de SEA l'auteur s'est vu réduit à discuter extensivement avec les utilisateurs afin de palier aux incompréhensions et erreurs diverses qu'il a fait lors de la première conception de l'algorithme.
Voici le cahier des charges final auquel il est arrivé.
\begin{itemize}
\item Chaque médecin doit recevoir approximativement le même nombre de gardes(c'est à dire personne ne doit avoir plus d'une garde de plus ou de moins que les autres)
\item Chaque médecin doit avoir un nombre minimum défini par l'utilisateur de jours de repos entre chaque garde
\item Chaque médecin doit avoir approximativement le même nombre de chaque jour de la semaine
\item Chaque médecin doit pouvoir marquer une période comme "vacances" et ne pas se voir assigner de garde durant cette période
\item Une date spécifique (eg jour férié) doit pouvoir être attribuée en avance à un médecin et le planning de garde généré de telle manière à lui permettre d'effectuer cette garde sans briser les règles précédentes
\end{itemize}

\section{Deuxième Version}
Après une phase extensive de tests un utilisateur potentiel a contacté l'auteur et lui a fait part de son intérêt pour le projet en cours.
L'utilisateur en question étant en charge de la rédaction du tableau de garde pour tout l'hopital l'algorithme correspondant au cahier des charges précédent ne lui était d'aucune utilité mais l'idée étant là une nouvelle itération eut lieu en collaboration avec lui afin de compléter l'algorithme pour le faire correspondre au nouveau cahier des charges.
\subsection{Cahier des Charges}
Le cahier des charges est essentiellement le même que celui de la première version mais avec l'ajout des contraintes qui suivent : 
\begin{itemize}
\item A chaque date deux médecins doivent être de garde : un médecin de garde aux urgences et un autre se déplaçant dans l'hopital pour aller là où son aide est requise.
Par la suite nous nous référerons à ce médecin comme le médecin d'intérieur.
\item tous les services ne peuvent pas fournir de médecins d'intérieur, mais tous peuvent fournir des médecins pour les urgences
\item le nombre de gardes de chaque médecin dépend de son ancienneté : les plus anciens n'en ont que trois sur la période définie, ceux en dessous cinq et les plus jeunes ont toutes les autres
\item les deux médecins de garde à chaque date ne doivent pas venir du même service
\item les deux médecins de garde à chaque date doivent venir de services différents de ceux qui ont fourni les médecins de garde de la veille
\end{itemize}

De ces contraintes naissent des contraintes d'intégrité évidentes (impossibilité de demander à être de garde d'intérieur à une date spécifique si on ne provient pas d'un service pouvant fournir des médecins d'intérieur, etc...).
Un autre problème a été de conserver la compatibilité entre les deux première version, c'est à dire la capacité à générer aussi bien un tableau de garde pour un seul service sur une courte durée que pour tout un hôpital sur une durée plus longue.

\chapter{Appendice}
\section{Améliorations à apporter}
Plusieurs améliorations pourront être apportées à duty planner par la suite, parmi elles la possibilité de changer la manière dont l'ancienneté (qui si on n'y réfléchit n'est qu'un score) modifie le nombre de gardes attribuées, la possibilité de marquer certains jours comme récurrents chaque mois (demander à être de garde le deuxième mardi de chaque mois) ou chaque année ("réserver" les noëls sur plusieurs années). Ces possibilités ne sont pas spécialement difficiles à implémenter mais elles semblaient hors du scope du projet. En effet les personnes générant les gardes le font sur des périodes de au maximum six mois et la rédaction puis la maintenance d'une masse de code supplémentaire semblait inutile\cite{yagn}.
\section{indent.awk}
Lors de la première implémentation de l'algorithme décrit plus avant, l'auteur s'est rapidement heurté à un problème d'indentation et de lisibilité du code. La quantité de code étant devenue trop grande et illisible pour une édition manuel il a mis au point et utilisé le script en awk qui suit
\begin{minted}[linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{awk}

	N { FS=" " 
	level = 0
	attendu[level] = "none"}

	function indent(level){
	for (i=(NF+level);i>level;i--){
				$i = $(i-level)
			}
			for(i = 1; i<= level; i++){
				$i = "  "
			}

	 }


	 /[Ww]hile/{
		indent(level)
		print $0
		level += 1
		attendu[level] = "wend"
		next
	 }

	 /^[Ii]f/{
		indent(level)
		print $0
		level += 1
		attendu[level] = "end"
		next
	 }

	 /^else/{
		indent(level-1)
		print $0
		next}

	 {if (level > 0 ) {
		if($1 ~ attendu[level]){
			level -= 1
			indent(level)
			print $0
			next
		}
	 }
	 }

	 {
		indent(level)
		print $0
	 }
\end{minted}
\end{document}
